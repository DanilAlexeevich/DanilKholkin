# Тема 6. Базовые коллекции: словари, кортежи 
Отчет по Теме #6 выполнил(а):
- Холкин Данил Алексеевич
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### В школе, где вы учились, узнали, что вы крутой программист и попросили написать программу для учителей, которая будет при вводе кабинета писать для него ключ доступа и статус, занят кабинет или нет. 
request = int(input('Введите номер кабинета: '))

dictionary = {

101: {'key': 1234, 'access': True},

102: {'key': 1337, 'access': True},

103: {'key': 8943, 'access': True},

104: {'key': 5555, 'access': False},

None: {'key': None, 'access': False},

}

response = dictionary.get(request)

if not response:

response = dictionary[None]

key = response.get('key')

access = response. get('access')

print(key, access)

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/1t6.png)

## Выводы
Код запрашивает у пользователя номер кабинета и проверяет, есть ли такой кабинет в словаре. Если номер существует, то программа выводит ключ и значение параметра access для этого кабинета.

## Лабораторная работа №2
### Алексей решил создать самый большой словарь в мире. Для этого он придумал функцию dict_maker (**kwargs), которая принимает неограниченное количество параметров «ключ: значение» и обновляет созданный им словарь my_dict, состоящий всего из одного элемента «first» со значением «so easy». Помогите Алексею создать данную функцию.
from pprint import pprint

my_dict = {'first': 'so easy'}

def dict_maker(**kwargs) :

my_dict.update(**kwargs)

dict_maker(a1=1, a2=20, a3=54, a4=13)

dict_maker(name='Михаил', age=31, weight=70, eyes_color='blue')

pprint(my_dict)
### Результат
 ![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/2t6.png)

## Выводы
Код создаёт словарь с помощью функции dict_maker(), которая принимает произвольное количество именованных аргументов (**kwargs) и добавляет их в существующий словарь my_dict с помощью метода .update().

## Лабораторная работа №3
### Для решения некоторых задач бывает необходимо разложить строку на отдельные символы. Мы знаем что это можно сделать при помощи split(), у которого более гибкая настройка для разделения для этого, но если нам нужно посимвольно разделить строку без всяких условий, то для этого мы можем использовать кортежи (tuple). 
input_string = 'HelloWorld'

result = tuple(input_string)

print(result)

print (list (result))

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/3t6.png)

## Выводы
Код принимает строку 'HelloWorld' и преобразует её в кортеж с помощью функции tuple(), а затем выводит полученный кортеж, после снова печатает преобразованный кортеж, но уже как список с помощью функции list(), которая преобразует кортеж в список.
  
## Лабораторная работа №4
### Вовочка решил написать крутую функцию, которая будет писать имя, возраст и место работы, но при этом на вход этой функции будет поступать кортеж. Помогите Вовочке написать эту программу.
def personal_info(name, age, company='unnamed' ):

print(f"Имя: {name} Возраст: {age} Компания: {company}")

tom = ("Григорий", 22)

personal_info(*tom)

bob = ("Георгий", 41, "Yandex")

personal_info(*bob)

### Результат

![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/4t6.png)
## Выводы
Функция выводит на экран строку с информацией о человеке, используя переданные аргументы.

## Лабораторная работа №5
### Для сопровождения первых лиц государства X нужен кортеж, но никто не может определиться с порядком машин, поэтому вам нужно написать функцию, которая будет сортировать кортеж, состоящий из целых чисел по возрастанию, и возвращает его. Если хотя бы один элемент не является целым числом, то функция возвращает исходный кортеж.
def tuple_sort(tpl):

for elm in tpl:
    
if not isinstance(elm, int):
        
return tpl
            
return tuple(sorted(tpl))

if __name__ == '__main__':

print (tuple_sort((5, 5, 3, 1, 9)))
    
print(tuple_sort((5, 5, 2.1, '1', 9)))

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/5t6.png)

## Выводы
Сортировка и возвращение кортежа

## Самостоятельная работа №1
### 1)	Ресторан на предприятии ведет учет посещений за неделю при помощи кода работника. У них есть список со всеми посещениями за неделю. Ваша задача почитать: Сколько было выдано чеков, Сколько разных людей посетило ресторан, Какой работник посетил ресторан больше всех раз.

checks_list = [
    8734, 2345, 8201, 6621, 9999, 1234, 5678, 8201, 8888, 4321, 3365,
    1478, 9865, 5555, 7777, 9998, 1111, 2222, 3333, 4444, 5556, 6666,
    5410, 7778, 8889, 4445, 1439, 9604, 8201, 3365, 7502, 3016, 4928,
    5837, 8201, 2643, 5017, 9682, 8530, 3250, 7193, 9051, 4506, 1987,
    3365, 5410, 7168, 7777, 8734, 5678, 8201, 4445, 3016, 4506, 4506
]

total_checks = len(checks_list)

unique_visitors = len(set(checks_list))

from collections import Counter
check_counts = Counter(checks_list)
most_frequent_visitor = check_counts.most_common(1)[0]

print('Выдано чеков :', total_checks, '\nУникальные персоны :', unique_visitors, '\nСамый посещаемый работник :', most_frequent_visitor)

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/6t6.png)

## Выводы 
Этот код работает со списком номеров чеков, определяет общее количество чеков, количество уникальных посетителей и находит номер чека, который встречается чаще всего. len() используется для подсчета общего количества чеков и уникальных посетителей. set() удаляет дубликаты. Counter из collections подсчитывает частоту появления каждого чека. most_common() находит самый часто встречающийся чек.
## Самостоятельная работа №2
### На физкультуре студенты сдавали бег, у преподавателя физкультуры есть список всех результатов, ему нужно узнать: Три лучшие результата, Три худшие результата, Все результаты начиная с 10 

run_results = [
    10.2, 14.8, 19.3, 22.7, 12.5, 33.1, 38.9, 21.6, 26.4, 17.1, 30.2,
    35.7, 16.9, 27.8, 24.5, 16.3, 18.7, 31.9, 12.9, 37.4
]

sorted_results = sorted(run_results)

top_3_results = sorted_results[:3]

bottom_3_results = sorted_results[-3:]

results_starting_from_10 = [time for time in run_results if time >= 10]

print('Топ 3 :' , top_3_results, '\n3 худших :', bottom_3_results, '\nВсе начиная с 10 :', results_starting_from_10)

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/7t6.png)

## Вывод
Этот код сортирует список результатов забегов, извлекает три лучших и три худших результата, а также создает новый список с результатами, которые равны или больше 10, после чего выводит топ-3, три худших результата и все результаты, начиная с 10. 
 
## Самостоятельная работа №3
### Преподаватель по математике придумал странную задачку. У вас есть три списка с элементами, каждый элемент которых – длина стороны треугольника, ваша задача найти площади двух треугольников, составленные из максимальных и минимальных элементов полученных списков.
three = [4, 21, 37, 56, 84]

max_values = [max(one), max(two), max(three)]

min_values = [min(one), min(two), min(three)]

def triangle_area(a, b, c):
    
s = (a + b + c) / 2
   
'#' Area calculation
    
return math.sqrt(s * (s - a) * (s - b) * (s - c))

max_triangle_area = triangle_area(*max_values)

min_triangle_area = triangle_area(*min_values)

print(max_triangle_area, min_triangle_area)

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/8t6.png)

## Вывод
Этот код создает два списка, содержащих максимальные и минимальные значения из трех списков (one, two, three), затем с помощью функции triangle_area вычисляет площади треугольников по этим значениям, используя формулу Герона для нахождения площади, и выводит на экран площади треугольников, построенных на максимальных и минимальных значениях.

## Самостоятельная работа №4
### Никто не любит получать плохие оценки, поэтому Борис решил это исправить. Допустим, что все оценки студента за семестр хранятся в одном списке. Ваша задача удалить из этого списка все двойки, а все тройки заменить на четверки.
def process_grades(grades):

return [4 if grade == 3 else grade for grade in grades if grade != 2]

grades_list_1 = [2, 3, 4, 5, 3, 4, 5, 2, 2, 5, 3, 4, 3, 5, 4]

grades_list_2 = [4, 2, 3, 5, 3, 5, 4, 2, 2, 5, 4, 3, 5, 3, 4]

grades_list_3 = [5, 4, 3, 3, 4, 3, 3, 5, 5, 3, 3, 3, 3, 4, 4]

updated_grades_1 = process_grades(grades_list_1)

updated_grades_2 = process_grades(grades_list_2)

updated_grades_3 = process_grades(grades_list_3)

print(updated_grades_1)

print(updated_grades_2)

print(updated_grades_3)

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/9t6.png)

## Вывод
Этот код создает функцию process_grades, которая обрабатывает список оценок: удаляет все оценки "2", заменяет все "3" на "4", а остальные оценки оставляет без изменений. Затем эта функция применяется к трем спискам оценок, и результат для каждого списка выводится на экран.

## Самостоятельная работа №5
### Вам предоставлены списки натуральных чисел, из них необходимо сформировать множества. При этом следует соблюдать это правило: если какое-либо число повторяется, то преобразовать его в строку по следующему образцу: например, если число 4 повторяется 3 раза, то в множестве будет следующая запись: само число 4, строка «44», строка «444».

from collections import Counter

'#' Function to transform the list into a set with the described rule

def list_to_set(lst):

counts = Counter(lst)
    
result_set = set()

for num, count in counts.items():
    
result_set.add(num)  # Add the number itself
        
for i in range(2, count + 1):
        
result_set.add(str(num) * i)  # Add the repeated number as strings

return result_set

'#' Provided lists

list_1 = [1, 1, 3, 3, 1]

list_2 = [5, 5, 5, 5, 5, 5, 5]

list_3 = [2, 2, 1, 2, 2, 5, 6, 7, 1, 3, 2, 2]

'#' Convert lists to sets

set_1 = list_to_set(list_1)

set_2 = list_to_set(list_2)

set_3 = list_to_set(list_3)

'#' Output the results

print(set_1)

print(set_2)

print(set_3)

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/10t6.png)

## Вывод
Этот код создает функцию list_to_set, которая преобразует список в множество с уникальными элементами, добавляя сам элемент и строковые представления его повторений, основанных на количестве его появлений в списке. Для этого используется класс Counter из модуля collections, который подсчитывает количество вхождений каждого элемента. После применения функции к трем спискам полученные множества выводятся на экран.

## Общие выводы по теме
Множества и списки — это важные типы данных в Python, которые используются для хранения и обработки коллекций элементов. Также списки удобны для работы с последовательностями данных, а множества — для работы с уникальными значениями и математическими операциями между коллекциями.
